use super::db_data::{
    album, album::Entity, album::Model, participant, participant::Entity as ParticipantEntity,
};
use application::command::shared::IdGenerator;
use chrono::Utc;
use domain::album::{Album, AlbumError, AlbumRepository};
use domain::value::AlbumId;
use sea_orm::sea_query::Value;
use sea_orm::*;
use std::sync::Arc;

#[derive(Clone)]
pub struct AlbumRepositoryImpl {
    db: sea_orm::DbConn,
    _id_generator: Arc<dyn IdGenerator>,
}

impl AlbumRepositoryImpl {
    pub fn new(db: sea_orm::DbConn, id_generator: Arc<dyn IdGenerator>) -> Self {
        AlbumRepositoryImpl {
            db,
            _id_generator: id_generator,
        }
    }
}

#[async_trait::async_trait]
impl AlbumRepository for AlbumRepositoryImpl {
    async fn save(&self, mut album: Album) -> Result<Album, AlbumError> {
        album.version += 1;

        // Use INSERT ... ON CONFLICT to upsert album by id
        // id is generated by snowflake and remains constant
        let now = Utc::now().naive_utc();

        let sql = String::from(
            "INSERT INTO album \
             (id, version, name, artist_id, genre_id, genre_ids, path_protocol, path_path, \
              max_year, min_year, max_original_year, min_original_year, date, original_date, \
              release_date, releases, compilation, sort_name, catalog_num, description, \
              create_time, update_time) \
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22) \
             ON CONFLICT (id) \
             DO UPDATE SET \
               version = EXCLUDED.version, \
               name = EXCLUDED.name, \
               artist_id = EXCLUDED.artist_id, \
               genre_id = EXCLUDED.genre_id, \
               genre_ids = EXCLUDED.genre_ids, \
               path_protocol = EXCLUDED.path_protocol, \
               path_path = EXCLUDED.path_path, \
               max_year = EXCLUDED.max_year, \
               min_year = EXCLUDED.min_year, \
               max_original_year = EXCLUDED.max_original_year, \
               min_original_year = EXCLUDED.min_original_year, \
               date = EXCLUDED.date, \
               original_date = EXCLUDED.original_date, \
               release_date = EXCLUDED.release_date, \
               releases = EXCLUDED.releases, \
               compilation = EXCLUDED.compilation, \
               sort_name = EXCLUDED.sort_name, \
               catalog_num = EXCLUDED.catalog_num, \
               description = EXCLUDED.description, \
               update_time = EXCLUDED.update_time \
             WHERE album.version < EXCLUDED.version",
        );

        let mut params: Vec<Value> = Vec::with_capacity(22);
        params.push(Value::BigInt(Some(album.id.clone().into())));
        params.push(Value::BigInt(Some(album.version)));
        params.push(Value::String(Some(Box::new(album.name.clone()))));
        params.push(Value::BigInt(Some(
            album.artist.clone().map(|a| a.into()).unwrap_or(0),
        )));
        params.push(Value::BigInt(Some(
            album.genre.clone().map(|g| g.into()).unwrap_or(0),
        )));
        params.push(Value::Array(
            sea_orm::sea_query::ArrayType::BigInt,
            Some(Box::new(
                album
                    .genres
                    .iter()
                    .map(|g| Value::BigInt(Some(Into::<i64>::into(g.clone()))))
                    .collect(),
            )),
        ));
        params.push(Value::String(Some(Box::new(album.path.protocol.clone()))));
        params.push(Value::String(Some(Box::new(album.path.path.clone()))));
        params.push(Value::Int(album.max_year));
        params.push(Value::Int(album.min_year));
        params.push(Value::Int(album.max_original_year));
        params.push(Value::Int(album.min_original_year));
        params.push(
            album
                .date
                .as_ref()
                .map(|s| Value::String(Some(Box::new(s.clone()))))
                .unwrap_or(Value::String(None)),
        );
        params.push(
            album
                .original_date
                .as_ref()
                .map(|s| Value::String(Some(Box::new(s.clone()))))
                .unwrap_or(Value::String(None)),
        );
        params.push(
            album
                .release_date
                .as_ref()
                .map(|s| Value::String(Some(Box::new(s.clone()))))
                .unwrap_or(Value::String(None)),
        );
        params.push(Value::Int(album.releases));
        params.push(Value::Bool(Some(album.compilation)));
        params.push(Value::String(Some(Box::new(album.sort_name.clone()))));
        params.push(
            album
                .catalog_num
                .as_ref()
                .map(|s| Value::String(Some(Box::new(s.clone()))))
                .unwrap_or(Value::String(None)),
        );
        params.push(
            album
                .description
                .as_ref()
                .map(|s| Value::String(Some(Box::new(s.clone()))))
                .unwrap_or(Value::String(None)),
        );
        params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
        params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        let result = self
            .db
            .execute(stmt)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;

        // Check if update was skipped due to version conflict
        // If rows_affected is 0, it means the WHERE condition (version check) failed
        // For new inserts, rows_affected will be 1
        // For updates that pass version check, rows_affected will be 1
        // For updates that fail version check, rows_affected will be 0
        if result.rows_affected() == 0 {
            // Version conflict - get the current version using a simple SELECT query by id
            let version_sql = "SELECT version FROM album WHERE id = $1";
            let version_params = vec![Value::BigInt(Some(album.id.clone().into()))];
            let version_stmt = Statement::from_sql_and_values(
                DbBackend::Postgres,
                version_sql.to_string(),
                version_params,
            );
            let version_result = self
                .db
                .query_one(version_stmt)
                .await
                .map_err(|e| AlbumError::DbErr(e.to_string()))?;

            if let Some(version_row) = version_result {
                let current_version: i64 = version_row
                    .try_get("", "version")
                    .map_err(|e| AlbumError::DbErr(format!("Failed to get version: {}", e)))?;
                return Err(AlbumError::VersionConflictErr(current_version));
            }
            return Err(AlbumError::DbErr(
                "Failed to insert or update album".to_string(),
            ));
        }

        // id and version are already set in album, no need to update them

        self.update_album_participants(&album.id, &album.participants)
            .await?;

        Ok(album)
    }

    async fn delete(&self, album_id: AlbumId) -> Result<(), AlbumError> {
        // Delete album participants first
        self.delete_album_participants(&album_id).await?;

        // Then delete the album
        Entity::delete_by_id(Into::<i64>::into(album_id))
            .exec(&self.db)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;
        Ok(())
    }

    async fn by_id(&self, album_id: AlbumId) -> Result<Option<Album>, AlbumError> {
        let result_row: Option<Model> = Entity::find_by_id(Into::<i64>::into(album_id))
            .one(&self.db)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;

        Ok(result_row.map(|row: Model| -> Album { row.into() }))
    }

    async fn find_by_sort_name(&self, sort_name: &String) -> Result<Option<Album>, AlbumError> {
        let result_row: Option<Model> = Entity::find()
            .filter(album::Column::SortName.eq(sort_name))
            .one(&self.db)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;

        Ok(result_row.map(|row: Model| -> Album { row.into() }))
    }
}

impl AlbumRepositoryImpl {
    /// Update album participants via UPSERT + DELETE diff
    async fn update_album_participants(
        &self,
        album_id: &AlbumId,
        new_participants: &[domain::value::Participant],
    ) -> Result<(), AlbumError> {
        self.upsert_album_participants(album_id, new_participants)
            .await?;
        self.delete_removed_album_participants(album_id, new_participants)
            .await?;
        Ok(())
    }

    /// Batch UPSERT new participants to maintain final state
    async fn upsert_album_participants(
        &self,
        album_id: &AlbumId,
        participants: &[domain::value::Participant],
    ) -> Result<(), AlbumError> {
        if participants.is_empty() {
            return Ok(());
        }

        let mut sql = String::from(
            "INSERT INTO participant \
             (work_id, work_type, artist_id, role, sub_role, create_time, update_time) VALUES ",
        );
        let mut params: Vec<Value> = Vec::with_capacity(participants.len() * 7);
        let mut placeholders: Vec<String> = Vec::with_capacity(participants.len());
        let now = Utc::now().naive_utc();

        for (i, participant) in participants.iter().enumerate() {
            let base = i * 7;
            placeholders.push(format!(
                "(${}, ${}, ${}, ${}, ${}, ${}, ${})",
                base + 1,
                base + 2,
                base + 3,
                base + 4,
                base + 5,
                base + 6,
                base + 7,
            ));

            params.push(Value::BigInt(Some(album_id.clone().into())));
            params.push(Value::String(Some(Box::new("Album".to_string()))));
            params.push(Value::BigInt(Some(participant.artist_id.clone().into())));
            params.push(Value::String(Some(Box::new(participant.role.to_string()))));
            let sub_role = participant.sub_role.as_ref().map(|sr| sr.clone().into());
            params.push(Value::String(sub_role.map(Box::new)));
            params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
            params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
        }

        sql.push_str(&placeholders.join(","));
        sql.push_str(
            " ON CONFLICT (work_id, work_type, artist_id, role) \
              DO UPDATE SET sub_role = EXCLUDED.sub_role, \
              update_time = EXCLUDED.update_time",
        );

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        self.db
            .execute(stmt)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;
        Ok(())
    }

    /// Delete participants not present in the new list
    async fn delete_removed_album_participants(
        &self,
        album_id: &AlbumId,
        participants: &[domain::value::Participant],
    ) -> Result<(), AlbumError> {
        let mut params: Vec<Value> = vec![Value::BigInt(Some(album_id.clone().into()))];
        let mut sql =
            String::from("DELETE FROM participant WHERE work_id = $1 AND work_type = 'Album'");

        if participants.is_empty() {
            let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
            self.db
                .execute(stmt)
                .await
                .map_err(|e| AlbumError::DbErr(e.to_string()))?;
            return Ok(());
        }

        // Build NOT IN clause for (artist_id, role) pairs
        let mut placeholders: Vec<String> = Vec::with_capacity(participants.len());
        for (idx, participant) in participants.iter().enumerate() {
            let base = idx * 2;
            placeholders.push(format!("(${}, ${})", base + 2, base + 3));
            params.push(Value::BigInt(Some(participant.artist_id.clone().into())));
            params.push(Value::String(Some(Box::new(participant.role.to_string()))));
        }

        sql.push_str(" AND (artist_id, role) NOT IN (");
        sql.push_str(&placeholders.join(", "));
        sql.push(')');

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        self.db
            .execute(stmt)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;

        Ok(())
    }

    /// Delete all album participants (fallback method)
    async fn delete_album_participants(&self, album_id: &AlbumId) -> Result<(), AlbumError> {
        ParticipantEntity::delete_many()
            .filter(participant::Column::WorkId.eq(Into::<i64>::into(album_id.clone())))
            .filter(participant::Column::WorkType.eq("Album"))
            .exec(&self.db)
            .await
            .map_err(|e| AlbumError::DbErr(e.to_string()))?;

        Ok(())
    }
}

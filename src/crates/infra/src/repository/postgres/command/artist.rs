use super::db_data::{
    artist,
    artist::Entity,
    artist::Model,
    participant::{self, Entity as ParticipantEntity, Model as ParticipantModel},
};
use application::command::shared::IdGenerator;
use async_trait::async_trait;
use chrono::Utc;
use domain::artist::{Artist, ArtistError, ArtistRepository};
use domain::value::{ArtistId, Participant};
use sea_orm::sea_query::Value;
use sea_orm::*;
use std::sync::Arc;

#[derive(Clone)]
pub struct ArtistRepositoryImpl {
    db: sea_orm::DbConn,
    id_generator: Arc<dyn IdGenerator>,
}

impl ArtistRepositoryImpl {
    pub fn new(db: sea_orm::DbConn, id_generator: Arc<dyn IdGenerator>) -> Self {
        Self { db, id_generator }
    }
}

#[async_trait]
impl ArtistRepository for ArtistRepositoryImpl {
    async fn find_by_sort_name(&self, sort_name: &String) -> Result<Option<Artist>, ArtistError> {
        let row: Option<Model> = Entity::find()
            .filter(artist::Column::SortName.eq(sort_name))
            .one(&self.db)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;

        if let Some(model) = row {
            let artist: Artist = model.into();
            // genres are already loaded from genre_ids field in Model
            Ok(Some(artist))
        } else {
            Ok(None)
        }
    }

    async fn save(&self, mut artist: Artist) -> Result<Artist, ArtistError> {
        artist.version += 1;
        let now = Utc::now().naive_utc();

        // Use INSERT ... ON CONFLICT to upsert artist by id
        // id is generated by snowflake and remains constant
        // create_time is set on insert, update_time is updated on conflict
        let sql = String::from(
            "INSERT INTO artist \
             (id, version, name, genre_id, genre_ids, sort_name, create_time, update_time) \
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8) \
             ON CONFLICT (id) \
             DO UPDATE SET \
               version = EXCLUDED.version, \
               name = EXCLUDED.name, \
               genre_id = EXCLUDED.genre_id, \
               genre_ids = EXCLUDED.genre_ids, \
               sort_name = EXCLUDED.sort_name, \
               update_time = EXCLUDED.update_time \
             WHERE artist.version < EXCLUDED.version",
        );

        let mut params: Vec<Value> = Vec::with_capacity(8);
        params.push(Value::BigInt(Some(artist.id.as_i64())));
        params.push(Value::BigInt(Some(artist.version)));
        params.push(Value::String(Some(Box::new(artist.name.clone()))));
        params.push(Value::BigInt(Some(
            artist.genre.as_ref().map(|g| g.as_i64()).unwrap_or(0),
        )));
        params.push(Value::Array(
            sea_orm::sea_query::ArrayType::BigInt,
            Some(Box::new(
                artist
                    .genres
                    .iter()
                    .map(|g| Value::BigInt(Some(g.as_i64())))
                    .collect(),
            )),
        ));
        params.push(Value::String(Some(Box::new(artist.sort_name.clone()))));
        params.push(Value::ChronoDateTime(Some(Box::new(now))));
        params.push(Value::ChronoDateTime(Some(Box::new(now))));

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        let result = self
            .db
            .execute(stmt)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;

        // Check if update was skipped due to version conflict
        if result.rows_affected() == 0 {
            // Version conflict - get the current version using a simple SELECT query by id
            let version_sql = "SELECT version FROM artist WHERE id = $1";
            let version_params = vec![Value::BigInt(Some(artist.id.as_i64()))];
            let version_stmt = Statement::from_sql_and_values(
                DbBackend::Postgres,
                version_sql.to_string(),
                version_params,
            );
            let version_result = self
                .db
                .query_one(version_stmt)
                .await
                .map_err(|e| ArtistError::DbErr(e.to_string()))?;

            if let Some(version_row) = version_result {
                let current_version: i64 = version_row
                    .try_get("", "version")
                    .map_err(|e| ArtistError::DbErr(format!("Failed to get version: {}", e)))?;
                return Err(ArtistError::VersionConflict(current_version));
            }
            return Err(ArtistError::DbErr(
                "Failed to insert or update artist".to_string(),
            ));
        }

        Ok(artist)
    }

    async fn delete(&self, artist_id: ArtistId) -> Result<(), ArtistError> {
        Entity::delete_by_id(Into::<i64>::into(artist_id))
            .exec(&self.db)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;
        Ok(())
    }

    async fn by_id(&self, id: ArtistId) -> Result<Option<Artist>, ArtistError> {
        let row = Entity::find_by_id(Into::<i64>::into(id))
            .one(&self.db)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;

        if let Some(model) = row {
            let artist: Artist = model.into();
            // genres are already loaded from genre_ids field in Model
            Ok(Some(artist))
        } else {
            Ok(None)
        }
    }
}

impl ArtistRepositoryImpl {
    /// Load participants for a specific artist
    pub async fn load_artist_participants(
        &self,
        artist_id: ArtistId,
    ) -> Result<Vec<Participant>, ArtistError> {
        let participant_models: Vec<ParticipantModel> = ParticipantEntity::find()
            .filter(participant::Column::ArtistId.eq(artist_id.as_i64()))
            .all(&self.db)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;

        Ok(participant_models
            .into_iter()
            .map(|model| model.into())
            .collect())
    }

    /// Save participants for a specific artist via UPSERT + DELETE diff
    pub async fn save_artist_participants(
        &self,
        artist_id: ArtistId,
        participants: &[Participant],
    ) -> Result<(), ArtistError> {
        self.upsert_artist_participants(artist_id.clone(), participants)
            .await?;
        self.delete_removed_artist_participants(artist_id, participants)
            .await?;
        Ok(())
    }

    /// Batch UPSERT new participants to maintain final state
    async fn upsert_artist_participants(
        &self,
        artist_id: ArtistId,
        participants: &[Participant],
    ) -> Result<(), ArtistError> {
        if participants.is_empty() {
            return Ok(());
        }

        let mut sql = String::from(
            "INSERT INTO participant \
             (work_id, work_type, artist_id, role, sub_role, create_time, update_time) VALUES ",
        );
        let mut params: Vec<Value> = Vec::with_capacity(participants.len() * 7);
        let mut placeholders: Vec<String> = Vec::with_capacity(participants.len());
        let now = Utc::now().naive_utc();

        for (i, participant) in participants.iter().enumerate() {
            let base = i * 7;
            placeholders.push(format!(
                "(${}, ${}, ${}, ${}, ${}, ${}, ${})",
                base + 1,
                base + 2,
                base + 3,
                base + 4,
                base + 5,
                base + 6,
                base + 7,
            ));

            params.push(Value::BigInt(Some(participant.work_id)));
            params.push(Value::String(Some(Box::new(
                participant.work_type.to_string(),
            ))));
            params.push(Value::BigInt(Some(artist_id.as_i64())));
            params.push(Value::String(Some(Box::new(participant.role.to_string()))));
            let sub_role = participant.sub_role.as_ref().map(|sr| sr.clone().into());
            params.push(Value::String(sub_role.map(Box::new)));
            params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
            params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
        }

        sql.push_str(&placeholders.join(","));
        sql.push_str(
            " ON CONFLICT (work_id, work_type, artist_id, role) \
              DO UPDATE SET sub_role = EXCLUDED.sub_role, \
              update_time = EXCLUDED.update_time",
        );

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        self.db
            .execute(stmt)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;
        Ok(())
    }

    /// Delete participants not present in the new list
    async fn delete_removed_artist_participants(
        &self,
        artist_id: ArtistId,
        participants: &[Participant],
    ) -> Result<(), ArtistError> {
        let mut params: Vec<Value> = vec![Value::BigInt(Some(artist_id.as_i64()))];
        let mut sql = String::from("DELETE FROM participant WHERE artist_id = $1");

        if participants.is_empty() {
            let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
            self.db
                .execute(stmt)
                .await
                .map_err(|e| ArtistError::DbErr(e.to_string()))?;
            return Ok(());
        }

        // Build NOT IN clause for (work_id, work_type, role) tuples
        let mut placeholders: Vec<String> = Vec::with_capacity(participants.len());
        for (idx, participant) in participants.iter().enumerate() {
            let base = idx * 3;
            placeholders.push(format!("(${}, ${}, ${})", base + 2, base + 3, base + 4));
            params.push(Value::BigInt(Some(participant.work_id)));
            params.push(Value::String(Some(Box::new(
                participant.work_type.to_string(),
            ))));
            params.push(Value::String(Some(Box::new(participant.role.to_string()))));
        }

        sql.push_str(" AND (work_id, work_type, role) NOT IN (");
        sql.push_str(&placeholders.join(", "));
        sql.push(')');

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        self.db
            .execute(stmt)
            .await
            .map_err(|e| ArtistError::DbErr(e.to_string()))?;

        Ok(())
    }
}

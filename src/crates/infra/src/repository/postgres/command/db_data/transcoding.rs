//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use domain::transcoding::Transcoding;
use domain::value::TranscodingId;
use sea_orm::{entity::prelude::*, ActiveValue::Set};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "transcoding")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[sea_orm(column_type = "BigInteger")]
    pub id: i64,
    #[sea_orm(unique)]
    pub name: String,
    #[sea_orm(unique)]
    pub target_format: String,
    pub command: String,
    pub default_bit_rate: i32,
    #[sea_orm(column_type = "BigInteger")]
    pub version: i64,
    pub parameters: String, // JSON string
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl From<&Transcoding> for ActiveModel {
    fn from(value: &Transcoding) -> Self {
        ActiveModel {
            id: Set(value.id.as_i64()),
            name: Set(value.name.clone()),
            target_format: Set(value.target_format.clone()),
            command: Set(value.command.clone()),
            default_bit_rate: Set(value.default_bit_rate),
            version: Set(value.version + 1),
            parameters: Set(serde_json::to_string(&value.parameters).unwrap_or_default()),
        }
    }
}

impl From<Model> for Transcoding {
    fn from(model: Model) -> Self {
        let parameters: HashMap<String, String> =
            serde_json::from_str(&model.parameters).unwrap_or_default();

        Self {
            id: TranscodingId::from(model.id),
            name: model.name,
            target_format: model.target_format,
            command: model.command,
            default_bit_rate: model.default_bit_rate,
            parameters,
            version: model.version,
        }
    }
}

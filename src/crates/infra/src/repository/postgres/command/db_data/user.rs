//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use domain::user::{User, UserStatus};
use sea_orm::entity::prelude::*;
use sea_orm::ActiveValue::{NotSet, Set};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[sea_orm(table_name = "user")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[sea_orm(column_type = "BigInteger")]
    pub id: i64,
    #[sea_orm(unique)]
    pub username: String,
    pub name: String,
    pub email: String,
    pub password: String,
    pub encrypted_password: String,
    pub is_admin: bool,
    pub status: i32,
    pub last_login_at: chrono::NaiveDateTime,
    pub last_access_at: chrono::NaiveDateTime,
    pub last_op_time: chrono::NaiveDateTime,
    pub version: i64,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    #[allow(dead_code)]
    None,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::None => panic!("No relations defined for User"),
        }
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<User> for ActiveModel {
    fn from(user: User) -> Self {
        let now = chrono::Utc::now().naive_utc();
        Self {
            id: Set(user.id.as_i64()),
            username: Set(user.username.clone()),
            name: Set(user.name.clone()),
            email: Set(user.email.clone()),
            password: Set(user.password.clone()),
            encrypted_password: Set(user.encrypted_password.clone()),
            is_admin: Set(user.is_admin),
            status: Set(user.status.into()),
            last_login_at: Set(user.last_login_at),
            last_access_at: Set(user.last_access_at),
            last_op_time: Set(user.last_op_time),
            version: Set(user.version),
            created_at: Set(now),
            updated_at: Set(now),
        }
    }
}

impl From<Model> for User {
    fn from(model: Model) -> Self {
        Self {
            id: model.id.into(),
            username: model.username,
            name: model.name,
            email: model.email,
            is_admin: model.is_admin,
            password: model.password,
            encrypted_password: model.encrypted_password,
            last_login_at: model.last_login_at,
            last_access_at: model.last_access_at,
            last_op_time: model.last_op_time,
            status: UserStatus::try_from(model.status).unwrap_or(UserStatus::Active),
            version: model.version,
            pending_events: Vec::new(), // Events are not persisted in the database
        }
    }
}

//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use domain::audio_file::{AudioFile, AudioFileMeta};
use domain::value::{AlbumId, ArtistId, AudioFileId, GenreId, LibraryId, MediaPath};
use sea_orm::entity::prelude::*;
use sea_orm::ActiveValue::{NotSet, Set};
use serde::{Deserialize, Serialize};
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "audio_file")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i64,
    #[sea_orm(column_type = "BigInteger")]
    pub library_id: i64,
    #[sea_orm(column_type = "BigInteger")]
    pub album_id: Option<i64>,
    #[sea_orm(column_type = "BigInteger")]
    pub artist_id: Option<i64>,
    pub path_protocol: String,
    pub path_path: String,
    #[sea_orm(column_type = "BigInteger")]
    pub size: i64,
    pub suffix: String,
    pub hash: Option<String>,
    pub duration: i64,
    pub bit_rate: i32,
    pub bit_depth: i32,
    pub sample_rate: i32,
    pub channels: i32,
    pub has_cover_art: bool,

    pub genre_id: i64,
    pub genre_ids: Vec<i64>,
    // AudioFileMeta fields
    pub title: String,
    pub track_number: Option<i32>,
    pub disc_number: Option<i32>,
    pub year: Option<i32>,
    pub date: Option<i32>,
    pub original_year: Option<i32>,
    pub original_date: Option<i32>,
    pub release_year: Option<i32>,
    pub release_date: Option<i32>,
    pub compilation: bool,
    pub bpm: Option<i32>,

    // Timestamps
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,

    // Version for optimistic locking
    pub version: i64,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    #[allow(dead_code)]
    None,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::None => panic!("No relations defined for AudioFile"),
        }
    }
}

impl ActiveModelBehavior for ActiveModel {}

/// Convert domain AudioFile to database ActiveModel
impl From<AudioFile> for ActiveModel {
    fn from(audio_file: AudioFile) -> Self {
        Self {
            id: Set(audio_file.id.as_i64()),
            library_id: Set(audio_file.library_id.as_i64()),
            album_id: Set(audio_file.album.map(|id| id.into())),
            artist_id: Set(audio_file.artist.map(|id| id.into())),
            path_protocol: Set(audio_file.path.protocol),
            path_path: Set(audio_file.path.path),
            size: Set(audio_file.size),
            suffix: Set(audio_file.suffix),
            hash: Set(audio_file.hash),
            duration: Set(audio_file.duration),
            bit_rate: Set(audio_file.bit_rate),
            bit_depth: Set(audio_file.bit_depth),
            sample_rate: Set(audio_file.sample_rate),
            channels: Set(audio_file.channels),
            has_cover_art: Set(audio_file.has_cover_art),
            genre_id: Set(audio_file.genre.as_ref().map(|id| id.as_i64()).unwrap_or(0)),
            genre_ids: Set(audio_file.genres.iter().map(|id| id.as_i64()).collect()),
            title: Set(audio_file.meta.title),
            track_number: Set(audio_file.meta.track_number),
            disc_number: Set(audio_file.meta.disc_number),
            year: Set(audio_file.meta.year),
            date: Set(audio_file.meta.date),
            original_year: Set(audio_file.meta.original_year),
            original_date: Set(audio_file.meta.original_date),
            release_year: Set(audio_file.meta.release_year),
            release_date: Set(audio_file.meta.release_date),
            compilation: Set(audio_file.meta.compilation),
            bpm: Set(audio_file.meta.bpm),
            created_at: Set(audio_file.created_at),
            updated_at: Set(audio_file.updated_at),
            version: Set(audio_file.version),
        }
    }
}

/// Convert database Model to domain AudioFile
impl From<Model> for AudioFile {
    fn from(model: Model) -> Self {
        let meta = AudioFileMeta {
            title: model.title,
            track_number: model.track_number,
            disc_number: model.disc_number,
            year: model.year,
            date: model.date,
            original_year: model.original_year,
            original_date: model.original_date,
            release_year: model.release_year,
            release_date: model.release_date,
            compilation: model.compilation,
            bpm: model.bpm,
        };

        Self {
            id: AudioFileId::from(model.id),
            album: model.album_id.map(|id| AlbumId::from(id)),
            artist: model.artist_id.map(|id| ArtistId::from(id)),
            genre: if model.genre_id != 0 {
                Some(GenreId::from(model.genre_id))
            } else {
                None
            },
            genres: model
                .genre_ids
                .iter()
                .map(|id| GenreId::from(*id))
                .collect(),
            participants: Vec::new(),
            path: MediaPath {
                protocol: model.path_protocol,
                path: model.path_path,
            },
            size: model.size,
            suffix: model.suffix,
            hash: model.hash,
            duration: model.duration,
            bit_rate: model.bit_rate,
            bit_depth: model.bit_depth,
            sample_rate: model.sample_rate,
            channels: model.channels,
            has_cover_art: model.has_cover_art,
            meta,
            library_id: LibraryId::from(model.library_id),
            created_at: model.created_at,
            updated_at: model.updated_at,
            events: Vec::new(), // Events are not persisted in the database
            version: model.version,
        }
    }
}

//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use sea_orm::entity::prelude::*;
use sea_orm::ActiveValue::{NotSet, Set};
use serde::{Deserialize, Serialize};

use domain::value::{ArtistId, ParticipantRole, ParticipantSubRole};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "participant")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = true)]
    #[sea_orm(column_type = "BigInteger")]
    pub id: i64,

    pub artist_id: i64,
    pub role: String,
    pub sub_role: Option<String>,
    pub work_id: i64,
    pub work_type: String,
    // Timestamps
    pub create_time: chrono::NaiveDateTime,
    pub update_time: chrono::NaiveDateTime,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    Album,
    Artist,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Relation::Album => Entity::belongs_to(super::album::Entity)
                .from(Column::WorkId)
                .to(super::album::Column::Id)
                .into(),
            Relation::Artist => Entity::belongs_to(super::artist::Entity)
                .from(Column::ArtistId)
                .to(super::artist::Column::Id)
                .into(),
        }
    }
}

impl Related<super::album::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Album.def()
    }
}

impl Related<super::artist::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Artist.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<Model> for domain::value::Participant {
    fn from(model: Model) -> Self {
        domain::value::Participant {
            artist_id: ArtistId::from(model.artist_id),
            role: ParticipantRole::from(model.role.as_str()),
            sub_role: model.sub_role.map(|s| ParticipantSubRole::from(s.as_str())),
            work_id: model.work_id,
            work_type: domain::value::ParticipantWorkType::from(model.work_type.as_str()),
        }
    }
}

impl From<&domain::value::Participant> for ActiveModel {
    fn from(participant: &domain::value::Participant) -> Self {
        let now = chrono::Utc::now().naive_utc();
        Self {
            id: NotSet, // 让数据库自动生成
            artist_id: Set(participant.artist_id.clone().into()),
            role: Set(participant.role.to_string()),
            sub_role: Set(participant.sub_role.as_ref().map(|s| s.to_string())),
            work_id: Set(participant.work_id),
            work_type: Set(participant.work_type.to_string()),
            create_time: Set(now),
            update_time: Set(now),
        }
    }
}

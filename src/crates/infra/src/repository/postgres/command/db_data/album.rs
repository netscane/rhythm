//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use sea_orm::entity::prelude::*;
use sea_orm::ActiveValue::{NotSet, Set};
use serde::{Deserialize, Serialize};

use domain::album as agg;
use domain::value::GenreId;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "album")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[sea_orm(column_type = "BigInteger")]
    pub id: i64,
    pub version: i64,

    // AlbumIdentity fields
    pub name: String, // album name

    pub artist_id: i64,

    pub genre_id: i64,

    pub genre_ids: Vec<i64>,

    // Media path
    pub path_protocol: String,
    pub path_path: String,

    // Year information
    pub max_year: Option<i32>,
    pub min_year: Option<i32>,
    pub max_original_year: Option<i32>,
    pub min_original_year: Option<i32>,

    // Date information
    pub date: Option<String>,
    pub original_date: Option<String>,
    pub release_date: Option<String>,

    // Album metadata
    pub releases: Option<i32>,
    pub compilation: bool,
    pub sort_name: String,
    pub catalog_num: Option<String>,

    pub description: Option<String>,

    // Timestamps
    pub create_time: chrono::NaiveDateTime,
    pub update_time: chrono::NaiveDateTime,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    //Annotation,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        panic!("No relations defined for Album")
    }
}

impl Related<super::artist::Entity> for Entity {
    fn to() -> RelationDef {
        panic!("No relations defined for Album")
    }
}

// No direct Genre relation because `album.genre_ids` is stored as a CSV string

/*
impl Related<super::annotation::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Annotation.def()
    }
}
*/

impl ActiveModelBehavior for ActiveModel {}

impl From<Model> for agg::Album {
    fn from(model: Model) -> Self {
        use domain::value::{AlbumId, MediaPath};

        // Clone fields that will be needed later to avoid moves
        let album_name = model.name.clone();
        let date = model.date.clone();
        let original_date = model.original_date.clone();
        let release_date = model.release_date.clone();
        let sort_name = model.sort_name.clone();
        let catalog_num = model.catalog_num.clone();

        let path = MediaPath {
            protocol: model.path_protocol,
            path: model.path_path,
        };

        let mut album = agg::Album::new(AlbumId::from(model.id), album_name, sort_name.clone());

        // Set additional fields that aren't in the constructor
        album.path = path;
        // Load genres from genre_ids array field
        album.genres = model.genre_ids.iter().map(|g| GenreId::from(*g)).collect();
        album.genre = if model.genre_id != 0 {
            Some(GenreId::from(model.genre_id))
        } else {
            None
        };

        album.max_year = model.max_year;
        album.min_year = model.min_year;
        album.date = date;
        album.max_original_year = model.max_original_year;
        album.min_original_year = model.min_original_year;
        album.original_date = original_date;
        album.release_date = release_date;
        album.releases = model.releases;
        album.compilation = model.compilation;
        album.sort_name = sort_name;
        album.catalog_num = catalog_num;
        album.description = model.description;
        album.version = model.version;

        album
    }
}

impl From<&agg::Album> for ActiveModel {
    fn from(album: &agg::Album) -> Self {
        let now = chrono::Utc::now().naive_utc();
        Self {
            id: Set(album.id.clone().into()),
            version: Set(album.version),
            name: Set(album.name.clone()),
            artist_id: Set(if let Some(artist_id) = &album.artist {
                artist_id.as_i64()
            } else {
                0
            }),
            genre_id: Set(if let Some(genre_id) = &album.genre {
                genre_id.as_i64()
            } else {
                0
            }),
            genre_ids: Set(album.genres.iter().map(|g| g.as_i64()).collect()),
            path_protocol: Set(album.path.protocol.clone()),
            path_path: Set(album.path.path.clone()),

            max_year: Set(album.max_year),
            min_year: Set(album.min_year),
            max_original_year: Set(album.max_original_year),
            min_original_year: Set(album.min_original_year),
            date: Set(album.date.clone()),
            original_date: Set(album.original_date.clone()),
            release_date: Set(album.release_date.clone()),
            releases: Set(album.releases),
            compilation: Set(album.compilation),
            sort_name: Set(album.sort_name.clone()),
            catalog_num: Set(album.catalog_num.clone()),
            description: Set(album.description.clone()),
            create_time: Set(now),
            update_time: Set(now),
        }
    }
}

//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use chrono::NaiveDateTime;
use domain::annotation::{Annotation, Kind};
use domain::value::{AnnotationId, UserId};
use sea_orm::ActiveValue::{NotSet, Set};
use sea_orm::{entity::prelude::*, sea_query::IntoCondition, ActiveModelBehavior};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[sea_orm(table_name = "annotation")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i64,
    pub user_id: i64,
    pub item_kind: String,
    pub item_id: i64,
    pub rating: i32,
    pub starred: bool,
    pub starred_at: NaiveDateTime,
    pub played_count: i32,
    pub played_at: NaiveDateTime,
    pub version: i64,
    pub created_at: NaiveDateTime,
    pub updated_at: NaiveDateTime,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    Album,
    Artist,
    User,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::Album => Entity::belongs_to(super::album::Entity)
                .from(Column::ItemId)
                .to(super::album::Column::Id)
                .on_condition(|_left, _right| Column::ItemKind.eq("album").into_condition())
                .into(),
            Self::Artist => Entity::belongs_to(super::artist::Entity)
                .from(Column::ItemId)
                .to(super::artist::Column::Id)
                .on_condition(|_left, _right| Column::ItemKind.eq("artist").into_condition())
                .into(),
            Self::User => Entity::belongs_to(super::user::Entity)
                .from(Column::UserId)
                .to(super::user::Column::Id)
                .into(),
        }
    }
}

impl Related<super::album::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Album.def()
    }
}

impl Related<super::artist::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Artist.def()
    }
}

impl Related<super::user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<Annotation> for ActiveModel {
    fn from(value: Annotation) -> Self {
        let now = chrono::Utc::now().naive_utc();

        ActiveModel {
            id: Set(value.id.as_i64()),
            user_id: Set(value.user_id.as_i64()),
            item_kind: Set(value.item_kind.to_string()),
            item_id: Set(value.item_id),
            rating: Set(value.rating),
            starred: Set(value.starred),
            starred_at: Set(value.starred_at),
            played_count: Set(value.played_count),
            played_at: Set(value.played_at),
            version: Set(value.version),
            created_at: Set(now),
            updated_at: Set(now),
        }
    }
}

impl Into<Annotation> for Model {
    fn into(self) -> Annotation {
        Annotation {
            id: AnnotationId::from(self.id),
            user_id: UserId::from(self.user_id),
            item_kind: self.item_kind.parse::<Kind>().unwrap_or(Kind::AudioFile),
            item_id: self.item_id,
            rating: self.rating,
            starred: self.starred,
            starred_at: self.starred_at,
            played_count: self.played_count,
            played_at: self.played_at,
            version: self.version,
            pending_events: Vec::new(),
        }
    }
}

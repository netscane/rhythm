//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use domain::artist::Artist;
use sea_orm::entity::prelude::*;
use sea_orm::ActiveValue::Set;
use serde::{Deserialize, Serialize};

use domain::value::GenreId;

//#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "artist")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i64,
    pub version: i64,

    pub name: String, // artist name

    pub genre_id: i64,
    pub genre_ids: Vec<i64>,

    // Artist metadata
    pub sort_name: String,

    // Timestamps
    pub create_time: chrono::NaiveDateTime,
    pub update_time: chrono::NaiveDateTime,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    Genre,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            /*
            Self::Annotation => Entity::has_many(annotation::Entity)
                .from(Column::Id)
                .to(annotation::Column::ItemId)
                .on_condition(|_left, _right| {
                    annotation::Column::ItemType
                        .eq(Entity.table_name())
                        .into_condition()
                })
                .into(),
            */
            Self::Genre => Entity::belongs_to(super::genre::Entity)
                .from(Column::GenreId)
                .to(super::genre::Column::Id)
                .into(),
        }
    }
}
/*
impl Related<annotation::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Annotation.def()
    }
}
*/

impl Related<super::genre::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Genre.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<Artist> for ActiveModel {
    fn from(artist: Artist) -> Self {
        Self {
            id: Set(artist.id.into()),
            version: Set(artist.version),
            name: Set(artist.name),
            genre_id: Set(artist.genre.map(|g| g.as_i64()).unwrap_or(0)),
            genre_ids: Set(artist.genres.iter().map(|g| g.as_i64()).collect()),
            sort_name: Set(artist.sort_name.clone()),
            // 时间戳由数据库自动管理
            create_time: sea_orm::ActiveValue::NotSet,
            update_time: sea_orm::ActiveValue::NotSet,
        }
    }
}

impl From<Model> for Artist {
    fn from(model: Model) -> Self {
        use domain::value::ArtistId;

        let mut artist = Artist::new(
            ArtistId::from(model.id),
            model.name.clone(),
            model.sort_name.clone(),
        );
        artist.genre = if model.genre_id != 0 {
            Some(GenreId::from(model.genre_id))
        } else {
            None
        };
        artist.genres = model.genre_ids.iter().map(|g| GenreId::from(*g)).collect();
        artist.version = model.version;
        artist
    }
}

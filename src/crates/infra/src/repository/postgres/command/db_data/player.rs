//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15

use chrono::Local;
use domain::player::{PlaybackMode, Player, PlayerState};
use domain::value::{PlayerId, UserId};
use sea_orm::{
    entity::prelude::*,
    ActiveValue::{NotSet, Set},
};
use serde::{Deserialize, Serialize};

//#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "player")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[sea_orm(column_type = "BigInteger")]
    pub id: i64,
    pub name: String,
    pub user_agent: String,
    #[sea_orm(column_type = "BigInteger")]
    pub user_id: i64,
    pub client: String,
    pub ip: String,
    pub last_seen: chrono::NaiveDateTime,
    pub max_bit_rate: i32,
    pub transcoding_id: String,
    pub report_real_path: u8,
    pub scrobble_enabled: u8,
    pub version: i32,
    pub last_op_time: chrono::NaiveDateTime,
    pub created_at: chrono::NaiveDateTime,
    pub updated_at: chrono::NaiveDateTime,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::user::Entity",
        from = "Column::UserId",
        to = "super::user::Column::Id"
    )]
    User,
}

impl Related<super::user::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::User.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<Player> for ActiveModel {
    fn from(value: Player) -> Self {
        let now = Local::now().naive_local();
        Self {
            id: Set(i64::from(value.id.clone())),
            name: Set(value.name),
            user_agent: Set(value.user_agent),
            user_id: Set(value.user_id.as_i64()),
            client: Set(value.client),
            ip: Set(value.ip),
            last_seen: Set(value.last_seen),
            max_bit_rate: Set(value.max_bit_rate),
            transcoding_id: Set(value.transcoding_id),
            report_real_path: Set(value.report_real_path as u8),
            scrobble_enabled: Set(value.scrobble_enabled as u8),
            version: Set(value.version),
            last_op_time: Set(value.last_op_time),
            created_at: Set(now),
            updated_at: Set(now),
        }
    }
}

impl From<Model> for Player {
    fn from(model: Model) -> Self {
        Player {
            id: PlayerId::from(model.id),
            name: model.name,
            user_id: UserId::from(model.user_id),
            user_agent: model.user_agent,
            client: model.client,
            ip: model.ip,
            last_seen: model.last_seen,
            max_bit_rate: model.max_bit_rate,
            transcoding_id: model.transcoding_id,
            report_real_path: model.report_real_path == 1,
            scrobble_enabled: model.scrobble_enabled == 1,
            version: model.version,
            last_op_time: model.last_op_time,
            state: PlayerState::Stopped,
            current_item: None,
            play_queue_id: None,
            volume: 100,
            mode: PlaybackMode::Sequential,
            pending_events: Vec::new(),
        }
    }
}

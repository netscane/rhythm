//! `SeaORM` Entity. Generated by sea-orm-codegen 0.12.15
use sea_orm::entity::prelude::*;
use sea_orm::ActiveValue::Set;
use serde::{Deserialize, Serialize};

use domain::genre as agg;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, DeriveEntityModel, Default)]
#[sea_orm(table_name = "genre")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    #[sea_orm(column_type = "BigInteger")]
    pub id: i64,
    #[sea_orm(unique)]
    pub name: String,
    #[sea_orm(column_type = "BigInteger")]
    pub version: i64,
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
    #[allow(dead_code)]
    None,
}

impl RelationTrait for Relation {
    fn def(&self) -> RelationDef {
        match self {
            Self::None => panic!("No relations defined for Genre"),
        }
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<Model> for agg::Genre {
    fn from(model: Model) -> Self {
        use domain::value::GenreId;

        let genre_name = agg::GenreName::new(model.name.clone()).unwrap_or_else(|_| {
            // Fallback if name validation fails
            agg::GenreName::new("[Unknown Genre]".to_string()).unwrap()
        });

        agg::Genre::new(GenreId::from(model.id), genre_name.clone())
            .unwrap()
            .with_version(model.version)
    }
}

impl From<agg::Genre> for ActiveModel {
    fn from(genre: agg::Genre) -> Self {
        Self {
            id: Set(genre.id.into()),
            name: Set(genre.name.value()),
            version: Set(genre.version),
        }
    }
}

use super::db_data::audio_file::{Column, Entity};
use super::db_data::participant::Entity as ParticipantEntity;
use chrono::Utc;
use domain::audio_file::{AudioFile, AudioFileError, AudioFileRepository};
use domain::value::{AudioFileId, MediaPath, Participant};
use sea_orm::entity::prelude::*;
use sea_orm::sea_query::Value;
use sea_orm::*;

#[derive(Clone)]
pub struct AudioFileRepositoryImpl {
    db: sea_orm::DbConn,
}

impl AudioFileRepositoryImpl {
    pub fn new(db: sea_orm::DbConn) -> Self {
        Self { db }
    }
}

#[async_trait::async_trait]
impl AudioFileRepository for AudioFileRepositoryImpl {
    async fn save(&self, mut audio: AudioFile) -> Result<AudioFile, AudioFileError> {
        // Use INSERT ... ON CONFLICT to upsert audio_file by id
        // id is generated by snowflake and remains constant
        audio.version += 1;
        let now = Utc::now().naive_utc();

        let sql = String::from(
            "INSERT INTO audio_file \
             (id, library_id, album_id, artist_id, path_protocol, path_path, size, suffix, hash, \
              duration, bit_rate, bit_depth, sample_rate, channels, has_cover_art, \
              genre_id, genre_ids, title, track_number, disc_number, year, date, \
              original_year, original_date, release_year, release_date, compilation, bpm, \
              created_at, updated_at, version) \
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31) \
             ON CONFLICT (id) \
             DO UPDATE SET \
               library_id = EXCLUDED.library_id, \
               album_id = EXCLUDED.album_id, \
               artist_id = EXCLUDED.artist_id, \
               path_protocol = EXCLUDED.path_protocol, \
               path_path = EXCLUDED.path_path, \
               size = EXCLUDED.size, \
               suffix = EXCLUDED.suffix, \
               hash = EXCLUDED.hash, \
               duration = EXCLUDED.duration, \
               bit_rate = EXCLUDED.bit_rate, \
               bit_depth = EXCLUDED.bit_depth, \
               sample_rate = EXCLUDED.sample_rate, \
               channels = EXCLUDED.channels, \
               has_cover_art = EXCLUDED.has_cover_art, \
               genre_id = EXCLUDED.genre_id, \
               genre_ids = EXCLUDED.genre_ids, \
               title = EXCLUDED.title, \
               track_number = EXCLUDED.track_number, \
               disc_number = EXCLUDED.disc_number, \
               year = EXCLUDED.year, \
               date = EXCLUDED.date, \
               original_year = EXCLUDED.original_year, \
               original_date = EXCLUDED.original_date, \
               release_year = EXCLUDED.release_year, \
               release_date = EXCLUDED.release_date, \
               compilation = EXCLUDED.compilation, \
               bpm = EXCLUDED.bpm, \
               updated_at = EXCLUDED.updated_at, \
               version = EXCLUDED.version \
             WHERE audio_file.version < EXCLUDED.version",
        );

        let mut params: Vec<Value> = Vec::with_capacity(31);
        params.push(Value::BigInt(Some(audio.id.as_i64())));
        params.push(Value::BigInt(Some(audio.library_id.as_i64())));
        params.push(
            audio
                .album
                .as_ref()
                .map(|id| Value::BigInt(Some(id.as_i64())))
                .unwrap_or(Value::BigInt(None)),
        );
        params.push(
            audio
                .artist
                .as_ref()
                .map(|id| Value::BigInt(Some(id.as_i64())))
                .unwrap_or(Value::BigInt(None)),
        );
        params.push(Value::String(Some(Box::new(audio.path.protocol.clone()))));
        params.push(Value::String(Some(Box::new(audio.path.path.clone()))));
        params.push(Value::BigInt(Some(audio.size)));
        params.push(Value::String(Some(Box::new(audio.suffix.clone()))));
        params.push(
            audio
                .hash
                .as_ref()
                .map(|s| Value::String(Some(Box::new(s.clone()))))
                .unwrap_or(Value::String(None)),
        );
        params.push(Value::BigInt(Some(audio.duration)));
        params.push(Value::Int(Some(audio.bit_rate)));
        params.push(Value::Int(Some(audio.bit_depth)));
        params.push(Value::Int(Some(audio.sample_rate)));
        params.push(Value::Int(Some(audio.channels)));
        params.push(Value::Bool(Some(audio.has_cover_art)));
        params.push(Value::BigInt(Some(
            audio.genre.as_ref().map(|g| g.as_i64()).unwrap_or(0),
        )));
        params.push(Value::Array(
            sea_orm::sea_query::ArrayType::BigInt,
            Some(Box::new(
                audio
                    .genres
                    .iter()
                    .map(|g| Value::BigInt(Some(g.as_i64())))
                    .collect(),
            )),
        ));
        params.push(Value::String(Some(Box::new(audio.meta.title.clone()))));
        params.push(Value::Int(audio.meta.track_number));
        params.push(Value::Int(audio.meta.disc_number));
        params.push(Value::Int(audio.meta.year));
        params.push(Value::Int(audio.meta.date));
        params.push(Value::Int(audio.meta.original_year));
        params.push(Value::Int(audio.meta.original_date));
        params.push(Value::Int(audio.meta.release_year));
        params.push(Value::Int(audio.meta.release_date));
        params.push(Value::Bool(Some(audio.meta.compilation)));
        params.push(Value::Int(audio.meta.bpm));
        // For new inserts, use current time; for updates, use existing created_at
        params.push(Value::ChronoDateTime(Some(Box::new(
            if audio.version == 0 {
                now.clone()
            } else {
                audio.created_at
            },
        ))));
        params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
        params.push(Value::BigInt(Some(audio.version)));

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        let result = self
            .db
            .execute(stmt)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;

        // Check if update was skipped due to version conflict
        if result.rows_affected() == 0 {
            // Version conflict - get the current version using a simple SELECT query by id
            let version_sql = "SELECT version FROM audio_file WHERE id = $1";
            let version_params = vec![Value::BigInt(Some(audio.id.as_i64()))];
            let version_stmt = Statement::from_sql_and_values(
                DbBackend::Postgres,
                version_sql.to_string(),
                version_params,
            );
            let version_result = self
                .db
                .query_one(version_stmt)
                .await
                .map_err(|e| AudioFileError::DbError(e.to_string()))?;

            if let Some(version_row) = version_result {
                let current_version: i64 = version_row.try_get("", "version").map_err(|e| {
                    AudioFileError::DbError(format!("Failed to get version: {}", e))
                })?;
                return Err(AudioFileError::DbError(format!(
                    "Version conflict: current version is {}",
                    current_version
                )));
            }
            return Err(AudioFileError::DbError(
                "Failed to insert or update audio_file".to_string(),
            ));
        }

        // Update participant relationships
        self.save_participant_relationships(&audio).await?;

        Ok(audio)
    }

    async fn find_by_id(&self, id: &AudioFileId) -> Result<Option<AudioFile>, AudioFileError> {
        let row = Entity::find_by_id(id.as_i64())
            .one(&self.db)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;

        if let Some(mut audio_file) = row.map(|m| m.into()) {
            // Load participant relationships
            self.load_participant_relationships(&mut audio_file).await?;
            Ok(Some(audio_file))
        } else {
            Ok(None)
        }
    }

    async fn find_by_path(&self, path: &MediaPath) -> Result<Option<AudioFile>, AudioFileError> {
        let row = Entity::find()
            .filter(Column::PathPath.eq(path.path.clone()))
            .filter(Column::PathProtocol.eq(path.protocol.clone()))
            .one(&self.db)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;

        if let Some(mut audio_file) = row.map(|m| m.into()) {
            // Load participant relationships
            self.load_participant_relationships(&mut audio_file).await?;
            Ok(Some(audio_file))
        } else {
            Ok(None)
        }
    }

    async fn delete(&self, id: &AudioFileId) -> Result<(), AudioFileError> {
        // Delete participant relationships first
        ParticipantEntity::delete_many()
            .filter(super::db_data::participant::Column::WorkId.eq(id.as_i64()))
            .filter(super::db_data::participant::Column::WorkType.eq("AudioFile"))
            .exec(&self.db)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;

        // Delete the audio file
        Entity::delete_by_id(id.as_i64())
            .exec(&self.db)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;
        Ok(())
    }
}

impl AudioFileRepositoryImpl {
    /// Update audio file participants via UPSERT + DELETE diff
    async fn save_participant_relationships(
        &self,
        audio_file: &AudioFile,
    ) -> Result<(), AudioFileError> {
        self.upsert_audio_file_participants(&audio_file.id, &audio_file.participants)
            .await?;
        self.delete_removed_audio_file_participants(&audio_file.id, &audio_file.participants)
            .await?;
        Ok(())
    }

    /// Batch UPSERT new participants to maintain final state
    async fn upsert_audio_file_participants(
        &self,
        audio_file_id: &AudioFileId,
        participants: &[Participant],
    ) -> Result<(), AudioFileError> {
        if participants.is_empty() {
            return Ok(());
        }

        let mut sql = String::from(
            "INSERT INTO participant \
             (work_id, work_type, artist_id, role, sub_role, create_time, update_time) VALUES ",
        );
        let mut params: Vec<Value> = Vec::with_capacity(participants.len() * 7);
        let mut placeholders: Vec<String> = Vec::with_capacity(participants.len());
        let now = Utc::now().naive_utc();

        for (i, participant) in participants.iter().enumerate() {
            let base = i * 7;
            placeholders.push(format!(
                "(${}, ${}, ${}, ${}, ${}, ${}, ${})",
                base + 1,
                base + 2,
                base + 3,
                base + 4,
                base + 5,
                base + 6,
                base + 7,
            ));

            params.push(Value::BigInt(Some(audio_file_id.as_i64())));
            params.push(Value::String(Some(Box::new("AudioFile".to_string()))));
            params.push(Value::BigInt(Some(participant.artist_id.clone().into())));
            params.push(Value::String(Some(Box::new(participant.role.to_string()))));
            let sub_role = participant.sub_role.as_ref().map(|sr| sr.clone().into());
            params.push(Value::String(sub_role.map(Box::new)));
            params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
            params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
        }

        sql.push_str(&placeholders.join(","));
        sql.push_str(
            " ON CONFLICT (work_id, work_type, artist_id, role) \
              DO UPDATE SET sub_role = EXCLUDED.sub_role, \
              update_time = EXCLUDED.update_time",
        );

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        self.db
            .execute(stmt)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;
        Ok(())
    }

    /// Delete participants not present in the new list
    async fn delete_removed_audio_file_participants(
        &self,
        audio_file_id: &AudioFileId,
        participants: &[Participant],
    ) -> Result<(), AudioFileError> {
        let mut params: Vec<Value> = vec![Value::BigInt(Some(audio_file_id.as_i64()))];
        let mut sql =
            String::from("DELETE FROM participant WHERE work_id = $1 AND work_type = 'AudioFile'");

        if participants.is_empty() {
            let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
            self.db
                .execute(stmt)
                .await
                .map_err(|e| AudioFileError::DbError(e.to_string()))?;
            return Ok(());
        }

        // Build NOT IN clause for (artist_id, role) pairs
        let mut placeholders: Vec<String> = Vec::with_capacity(participants.len());
        for (idx, participant) in participants.iter().enumerate() {
            let base = idx * 2;
            placeholders.push(format!("(${}, ${})", base + 2, base + 3));
            params.push(Value::BigInt(Some(participant.artist_id.clone().into())));
            params.push(Value::String(Some(Box::new(participant.role.to_string()))));
        }

        sql.push_str(" AND (artist_id, role) NOT IN (");
        sql.push_str(&placeholders.join(", "));
        sql.push(')');

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        self.db
            .execute(stmt)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;

        Ok(())
    }

    /// Load participant relationships for an audio file
    async fn load_participant_relationships(
        &self,
        audio_file: &mut AudioFile,
    ) -> Result<(), AudioFileError> {
        let relationships = ParticipantEntity::find()
            .filter(super::db_data::participant::Column::WorkId.eq(audio_file.id.as_i64()))
            .filter(super::db_data::participant::Column::WorkType.eq("AudioFile"))
            .all(&self.db)
            .await
            .map_err(|e| AudioFileError::DbError(e.to_string()))?;

        audio_file.participants = relationships.into_iter().map(|r| r.into()).collect();
        Ok(())
    }
}

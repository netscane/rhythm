use super::db_data::{cover_art, cover_art::Entity};
use application::command::shared::IdGenerator;
use chrono::Utc;
use domain::cover_art::{CoverArt, CoverArtError, CoverArtRepository};
use domain::value::{AlbumId, CoverArtId};
use sea_orm::sea_query::Value;
use sea_orm::*;
use std::sync::Arc;

#[derive(Clone)]
pub struct CoverArtRepositoryImpl {
    db: sea_orm::DbConn,
    _id_generator: Arc<dyn IdGenerator>,
}

impl CoverArtRepositoryImpl {
    pub fn new(db: sea_orm::DbConn, id_generator: Arc<dyn IdGenerator>) -> Self {
        CoverArtRepositoryImpl {
            db,
            _id_generator: id_generator,
        }
    }
}

#[async_trait::async_trait]
impl CoverArtRepository for CoverArtRepositoryImpl {
    async fn save(&self, mut cover_art: CoverArt) -> Result<CoverArt, CoverArtError> {
        let cover_art_version = cover_art.version + 1;

        // Use INSERT ... ON CONFLICT to upsert cover art by id
        // id is generated by snowflake and remains constant
        let now = Utc::now().naive_utc();

        let sql = String::from(
            "INSERT INTO cover_art \
             (id, version, audio_file_id, album_id, path_protocol, path_path, width, height, \
              format, file_size, source, created_at, updated_at) \
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) \
             ON CONFLICT (id) \
             DO UPDATE SET \
               version = EXCLUDED.version, \
               audio_file_id = EXCLUDED.audio_file_id, \
               album_id = EXCLUDED.album_id, \
               path_protocol = EXCLUDED.path_protocol, \
               path_path = EXCLUDED.path_path, \
               width = EXCLUDED.width, \
               height = EXCLUDED.height, \
               format = EXCLUDED.format, \
               file_size = EXCLUDED.file_size, \
               source = EXCLUDED.source, \
               updated_at = EXCLUDED.updated_at \
             WHERE cover_art.version < EXCLUDED.version",
        );

        let mut params: Vec<Value> = Vec::with_capacity(13);
        params.push(Value::BigInt(Some(cover_art.id.clone().into())));
        params.push(Value::BigInt(Some(cover_art_version)));
        params.push(Value::BigInt(
            cover_art.audio_file_id.as_ref().map(|id| id.clone().into()),
        ));
        params.push(Value::BigInt(None)); // album_id, not used in current domain model
        params.push(Value::String(Some(Box::new(
            cover_art.path.protocol.clone(),
        ))));
        params.push(Value::String(Some(Box::new(cover_art.path.path.clone()))));
        params.push(Value::Int(cover_art.width));
        params.push(Value::Int(cover_art.height));
        params.push(Value::String(cover_art.format.as_ref().map(|f| Box::new(f.to_string()))));
        params.push(Value::BigInt(Some(cover_art.file_size)));
        params.push(Value::String(Some(Box::new(cover_art.source.to_string()))));
        params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));
        params.push(Value::ChronoDateTime(Some(Box::new(now.clone()))));

        let stmt = Statement::from_sql_and_values(DbBackend::Postgres, sql, params);
        let result = self
            .db
            .execute(stmt)
            .await
            .map_err(|e| CoverArtError::DatabaseError {
                message: e.to_string(),
            })?;

        // Check if update was skipped due to version conflict
        // If rows_affected is 0, it means the WHERE condition (version check) failed
        // For new inserts, rows_affected will be 1
        // For updates that pass version check, rows_affected will be 1
        // For updates that fail version check, rows_affected will be 0
        if result.rows_affected() == 0 {
            // Version conflict - get the current version using a simple SELECT query by id
            let version_sql = "SELECT version FROM cover_art WHERE id = $1";
            let version_params = vec![Value::BigInt(Some(cover_art.id.clone().into()))];
            let version_stmt = Statement::from_sql_and_values(
                DbBackend::Postgres,
                version_sql.to_string(),
                version_params,
            );
            let version_result = self.db.query_one(version_stmt).await.map_err(|e| {
                CoverArtError::DatabaseError {
                    message: e.to_string(),
                }
            })?;

            if let Some(version_row) = version_result {
                let current_version: i64 = version_row.try_get("", "version").map_err(|e| {
                    CoverArtError::DatabaseError {
                        message: format!("Failed to get version: {}", e),
                    }
                })?;
                return Err(CoverArtError::VersionConflict {
                    expected: current_version,
                    actual: cover_art_version,
                });
            }
            return Err(CoverArtError::DatabaseError {
                message: "Failed to insert or update cover art".to_string(),
            });
        }

        // Update the version in the returned object to match database
        cover_art.version = cover_art_version;
        Ok(cover_art)
    }

    async fn find_by_id(&self, id: &CoverArtId) -> Result<Option<CoverArt>, CoverArtError> {
        let row = Entity::find_by_id(Into::<i64>::into(id.clone()))
            .one(&self.db)
            .await
            .map_err(|e| CoverArtError::DatabaseError {
                message: e.to_string(),
            })?;
        Ok(row.map(|m| m.into()))
    }

    async fn find_by_album_id(&self, album_id: &AlbumId) -> Result<Vec<CoverArt>, CoverArtError> {
        let rows = Entity::find()
            .filter(cover_art::Column::AlbumId.eq(Into::<i64>::into(album_id.clone())))
            .all(&self.db)
            .await
            .map_err(|e| CoverArtError::DatabaseError {
                message: e.to_string(),
            })?;

        Ok(rows.into_iter().map(|m| m.into()).collect())
    }

    async fn delete(&self, id: &CoverArtId) -> Result<(), CoverArtError> {
        Entity::delete_by_id(Into::<i64>::into(id.clone()))
            .exec(&self.db)
            .await
            .map_err(|e| CoverArtError::DatabaseError {
                message: e.to_string(),
            })?;
        Ok(())
    }
}
